#!/usr/bin/env python3
"""
Description: Protects song by adding metadata or any other security measures
Use: Once per song
"""
import json
import struct
import math
import os
import wave
import base64
from argparse import ArgumentParser
import numpy as np
from Cryptodome.Cipher import AES
from Cryptodome.PublicKey import RSA
from Cryptodome.Signature import pss
from Cryptodome.Hash import SHA256, HMAC
from Cryptodome.Util.Padding import pad

CHUNK_SZ = 16000


'''
n - length of the last string hashed
s - ring buffer used for the internal state (32 words - 2048 bits)
      an element s[i] is a 64-bit word, which is the ith element of the buffer,
      wrapping around if necessary, when the index i becomes too large for the
      buffer
'''

def glowwormAddBit(b, s, n, t):
   if b == 1:
      t = s[n % 32] ^ 0xffffffff
   else:
      t = s[n % 32] ^ 0
   t = (t|(t>>1 & 0xffffffffffffffff)) ^ (t<<1 & 0xffffffffffffffff)
   t ^= (t>>4 & 0xffffffffffffffff) ^ (t>>8 & 0xffffffffffffffff) ^ (t>>16 & 0xffffffffffffffff) ^ (t>>32 & 0xffffffffffffffff)
   n = n + 1
   s[n % 32] = s[n % 32] ^ t
   h = s[n % 32] & 0xffffffffffffffff
   return h, s, n, t

def glowwormInit(s, n, t, h):
   for i in range(4096):
      h, s, n, t = glowwormAddBit((h & 1), s, n, t)
   return s, n, t, h

def glowwormHash(data, dataLen):
   CHECKVALUE = 0xCCA4220FC78D45E0
   s = [0] * 32
   h = 1
   n = 0
   t = 0

   s, n, t, h = glowwormInit(s, n, t, h)
   assert(h == CHECKVALUE)
   
   for idx in range(dataLen):
      currByte = data[idx]
      for bIdx in range(7, -1, -1):
         if ((currByte & (1<<bIdx))>>bIdx) == 0:
            bit = 0
         else:
            bit = 1
         h, s, n, t = glowwormAddBit(bit,s,n,t)

   return h

class ProtectedSong(object):
    """Example song object for protected song"""

    def __init__(self, path_to_song, metadata, path_to_keys):
        """initialize values
        Args:
            path_to_song (string): file name where the song to be provisioned is stored
            metadata (bytearray): bytes containing metadata information
        """
        self.song = path_to_song
        self.full_song, self.original_song = self.read_song(path_to_song)
        self.metadata = metadata
        self.path_to_keys = path_to_keys

    def save_secured_song_to_wave(self, file_location):
        """Saves secured song to wave file assuming all the same characteristics as original song
        Args:
            file_location (string): location to store the file including name"""
        protected_wav = wave.open(os.path.abspath(file_location), 'wb')
        protected_wav.setnchannels(self.original_song.getnchannels())
        protected_wav.setsampwidth(self.original_song.getsampwidth())
        protected_wav.setframerate(self.original_song.getframerate())

        # read AES 256 bit key
        aes = open(os.path.abspath(self.path_to_keys+'aes_key'),'rb')
        aes_key = aes.read(32)
        aes.close()

        # read HMAC keys
        hmacKey1File = open(os.path.abspath(self.path_to_keys+'hmac_md_key'),'rb')
        hmacKey1 = hmacKey1File.read()
        hmacKey1File.close()

        hmacKey2File = open(os.path.abspath(self.path_to_keys+'hmac_chunk_key'),'rb')
        hmacKey2 = hmacKey2File.read()
        hmacKey2File.close()

        # encrypt audio data using AES-256
        cipher = AES.new(aes_key, AES.MODE_CBC)
        enc_audio = cipher.encrypt(pad(bytes(self.full_song), AES.block_size)) #use pkcs7

        # calculate and convert total chucks and encrypted song length 
        numChunks = math.ceil(len(enc_audio) / CHUNK_SZ)
        nChunksBytes = (numChunks).to_bytes(4, byteorder='little', signed=False)
        eAudioLenBytes = len(enc_audio).to_bytes(4, byteorder='little', signed=False)

        chunkHashes = [bytes()] * numChunks      

        print('Hashing chunks (this will take awhile)...')
        for i in range(1, numChunks+1):
            # create glowworm hash of [enc audio chunk + iv + chunk key]
            chunk = enc_audio[(i*CHUNK_SZ)-CHUNK_SZ:i*CHUNK_SZ]
            data = chunk + cipher.iv + hmacKey2
            dataLen = len(chunk) + len(cipher.iv) + len(hmacKey2)
            glowworm_chunk_hash = glowwormHash(data, dataLen).to_bytes(8, byteorder='little', signed=False)
            print(glowworm_chunk_hash)
            chunkHashes[i-1] = glowworm_chunk_hash
        
        # create glowworm hash of [iv + nchunks + e_audio_len + MD + metadata key]
        data = cipher.iv + nChunksBytes + eAudioLenBytes + self.metadata + hmacKey1
        dataLen = len(cipher.iv) + len(nChunksBytes) + len(eAudioLenBytes) + len(self.metadata) + len(hmacKey1)
        glowworm_md_hash = glowwormHash(data, dataLen).to_bytes(8, byteorder='little', signed=False)
        print('success')

        print('Writing everything to .drm file...')
        # write everything to file
        protected_wav.writeframes(glowworm_md_hash)
        protected_wav.writeframes(cipher.iv)
        protected_wav.writeframes(nChunksBytes)
        protected_wav.writeframes(eAudioLenBytes)
        protected_wav.writeframes(self.metadata)
        protected_wav.writeframes(enc_audio)
        print(chunkHashes[0])
        for gwhash in chunkHashes:
            protected_wav.writeframes(gwhash)

        protected_wav.close()

    def read_song(self, path, metadata_frames=0):
        """Reads a wave file
        Args:
            path (string): path to song
            metadata_frames (int): if not 0 disregard this number of frames as metadata
        Returns:
            vals (array): integer array of decoded values
            song (Wave Object): wave object associated with entered song
        """
        song = wave.open(os.path.abspath(path), 'r')
        if metadata_frames:
            song.readframes(metadata_frames)  # skip the metadata frames when assigning vals
        vals = np.frombuffer(song.readframes(song.getnframes()), dtype=np.int16)
        song.close()
        return vals, song


def create_metadata(regions, user, user_secret_location, region_info):
    """Returns a byte string formatted as follows:
    METADATA_LENGTH(1B)/ownerID(1B)/REGION_LEN(1B)/USER_LEN(1B)/REGIONID1(1B)/REGIONID2 (1B)/.../padding
    Args:
        regions (list): list of regions to provision song for
        user (string): user name for owner of the song
        user_secret_location (string): path to user secrets file
        region_info (dict): mapping of regions provided by region_information.json
    Returns:
        metadata (bytes): bytes of encoded metadata, padded to 100 bytes
    Example:
        >>create_metadata(['USA', 'Canada'], 'user1', 'user_secrets.json', {'USA': 1, 'Canada':2})
        'x06/x00/x01/x00/x01/x02' + 94 null bytes
    Max users: 64
    Max regions: 32
    Max length of metadata is 1+1+1+1+32+63+1 = 100
    """
    user_secrets = json.load(open(os.path.abspath(user_secret_location)))

    # note: metadata must be an even length since each sample is 2B long
    # and ARM processors require memory accesses to be aligned to the type size
    metadata = struct.pack(
        '=3B{regions_length}s'.format(regions_length=len(regions)),
        int(user_secrets[user]['id']), len(regions), 0,
        bytes([region_info[str(r)] for r in regions]))

    md_len = len(metadata) + 1
    pad_len = 100 - md_len
    return bytes([md_len]) + metadata + (b'\x00'*pad_len)


def main():
    parser = ArgumentParser(description='main interface to protect songs')
    parser.add_argument('--region-list', nargs='+', help='List of regions song can be played in', required=True)
    parser.add_argument('--region-secrets-path', help='File location for the region secrets file',
                        required=True)
    parser.add_argument('--outfile', help='path to save the protected song', required=True)
    parser.add_argument('--infile', help='path to unprotected song', required=True)
    parser.add_argument('--owner', help='owner of song', required=True)
    parser.add_argument('--user-secrets-path', help='File location for the user secrets file', required=True)
    args = parser.parse_args()

    regions = json.load(open(os.path.abspath(args.region_secrets_path)))
    try:
        metadata = create_metadata(args.region_list, args.owner, args.user_secrets_path, regions)
    except ValueError:
        raise ValueError('Ensure all user IDs are integers and all regions are in the provided region_information.json')

    keys_path = get_path(args.user_secrets_path)

    protected_song = ProtectedSong(args.infile, metadata, keys_path)
    protected_song.save_secured_song_to_wave(args.outfile)

# removes filename from path
# Ex. './a/b/file.txt' --> './a/b/'
#     'file.txt'       --> ''
def get_path(full_path):
    found = False
    for i in range(len(full_path)-1, 0, -1):
        if full_path[i] == '/':
            found = True
            break
    dir = ''
    if found:
        dir = full_path[:i] + '/'
    return dir

if __name__ == '__main__':
    main()
