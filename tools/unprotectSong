#!/usr/bin/env python3
"""
Description: Unprotects song by removing signature, metadata, and decrypting audio
Use: Once per encrypted song
"""

import os
import wave
import struct
import numpy as np
from argparse import ArgumentParser
from Crypto.Cipher import AES
from Crypto.Hash import SHA256
from Crypto.PublicKey import RSA
from Crypto.Signature import PKCS1_PSS
from Crypto.Util.Padding import unpad

def unprotect(infile, outfile, aeskey_f, rsapublic_f):
   # read aeskey_f into byte buffer
   try:
      aes = open(os.path.abspath(aeskey_f), 'rb')
   except Exception as e:
      print('Unable to open aes_key file: %s' % (e,))
      return 0
   aes_key = aes.read(32) #256/8
   aes.close()

   #read rsapublic_f into buffer
   try:
      rsa = open(os.path.abspath(rsapublic_f), 'rb')
   except Exception as e:
      print('Unable to open rsa_public.pem file: %s' % (e,))
      return 0
   rsa_pubkey = rsa.read()
   rsa.close()

   # wave.open infile
   try:
      protected = wave.open(os.path.abspath(infile), 'rb')
   except Exception as e:
      print('Unable to open infile: %s' % (e,))
      return 0

   # save wav metadata using getnchannels, getsampwidth, getframerate
   nchannels = protected.getnchannels()
   sampwidth = protected.getsampwidth()
   framerate = protected.getframerate()

   # read data and close infile
   nframes = protected.getnframes()
   data = np.frombuffer(protected.readframes(nframes), dtype=np.int16)
   protected.close()

   # remove signature
   end_signature = 256 #because of SHA256
   signature = bytes(data[:end_signature])
   md_and_audio = bytes(data[end_signature:])

   verifier = PKCS1_PSS.new(RSA.importKey(rsa_pubkey))
   h = SHA256.new(md_and_audio)
   if verifier.verify(h, signature):
      print('Success: signature verified')
   else:
      print('ERROR: COULD NOT VERIFY SIGNATURE')

   # decrypt audio using AES key
   md_size = data[end_signature:][0] #first byte of song metadata is length
   start_audio = end_signature+md_size
   e_audio = bytes(data[start_audio:])
   iv = e_audio[:AES.block_size]
   cipher = AES.new(aes_key, AES.MODE_CBC, iv)
   try:
      audio = unpad(cipher.decrypt(e_audio[AES.block_size:]), AES.block_size)
   except Exception as e:
      print('Unable to unpad encrypted audio: %s' % (e,))
      return 0

   # wave.open outfile
   try:
      unprotected = wave.open(os.path.abspath(outfile), 'wb')
   except Exception as e:
      print('Unable to open outfile: %s' % (e,))
      return 0

   # set outfile metadata to saved wav metadata
   unprotected.setnchannels(nchannels)
   unprotected.setsampwidth(sampwidth)
   unprotected.setframerate(framerate)

   # write decrypted audio using writeframes
   audio_arr = audio.getBytes("UTF8") #VERIFY IF THIS IS RIGHT
   for val in audio_arr:
      unprotected_val = struct.pack('<h', val)
      unprotected.writeframesraw(unprotected_val)

   # close outfile
   unprotected.close()

def main():
   parser = ArgumentParser(description='main interface to unprotect songs')
   parser.add_argument('--outfile', help='path to save the unprotected song', required=True)
   parser.add_argument('--infile', help='path to protected song', required=True)
   parser.add_argument('--aeskeyfile', help='path to AES key file', required=True)
   parser.add_argument('--rsapublickeyfile', help='path to RSA public key file', required=True)
   args = parser.parse_args()

   unprotect(args.infile, args.outfile, args.aeskeyfile, args.rsapublickeyfile)

if __name__ == '__main__':
   main()
