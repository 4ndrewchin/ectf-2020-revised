#!/usr/bin/env python3
"""
Description: Unprotects song by removing signature, metadata, and decrypting audio
Use: Once per encrypted song
"""

import os
import wave
import struct
import numpy as np
from argparse import ArgumentParser
from Cryptodome.Cipher import AES
from Cryptodome.Hash import SHA256
from Cryptodome.PublicKey import RSA
from Cryptodome.Signature import pss
from Cryptodome.Util.Padding import unpad

def unprotect(infile, outfile, aeskey_f, rsapublic_f):
   # read aeskey_f into byte buffer
   try:
      aes = open(os.path.abspath(aeskey_f), 'rb')
   except Exception as e:
      print('Unable to open aes_key file: %s' % (e,))
      return 0
   aes_key = aes.read(32) #256/8
   aes.close()

   #read rsapublic_f into buffer
   try:
      rsa = open(os.path.abspath(rsapublic_f), 'rb')
   except Exception as e:
      print('Unable to open rsa_public.der file: %s' % (e,))
      return 0
   rsa_pubkey = rsa.read()
   rsa.close()

   # wave.open infile
   try:
      protected = wave.open(os.path.abspath(infile), 'rb')
   except Exception as e:
      print('Unable to open infile: %s' % (e,))
      return 0

   # save wav metadata using getnchannels, getsampwidth, getframerate
   nchannels = protected.getnchannels()
   sampwidth = protected.getsampwidth()
   framerate = protected.getframerate()

   # read data and close infile
   nframes = protected.getnframes()
   data = np.frombuffer(protected.readframes(nframes), dtype=np.int16)
   data = data.tobytes()
   protected.close()

   # remove signature
   end_signature = 256 # bits, not bytes
   signature = data[:end_signature]
   md_and_audio = data[end_signature:]

   verifier = pss.new(RSA.importKey(rsa_pubkey))
   h = SHA256.new(md_and_audio)
   print('Verifying signature...', end='')
   try:
      verifier.verify(h, signature)
   except Exception as e:
      print('error: %s' % (e,))
      return 0
   print('success')

   # decrypt audio using AES key
   md_size = data[end_signature:][0] #first byte of song metadata is length
   if md_size > 100:
      print('Something is wrong. Metadata max size is 100, got %s' % md_size)
      return 0
   start_audio = end_signature+md_size
   e_audio = data[start_audio:]
   iv = e_audio[:AES.block_size]
   cipher = AES.new(aes_key, AES.MODE_CBC, iv)
   try:
      audio = unpad(cipher.decrypt(e_audio[AES.block_size:]), AES.block_size) #use pkcs7
   except Exception as e:
      print('Unable to unpad encrypted audio: %s' % (e,))
      return 0

   # wave.open outfile
   try:
      unprotected = wave.open(os.path.abspath(outfile), 'wb')
   except Exception as e:
      print('Unable to open outfile: %s' % (e,))
      return 0

   # set outfile metadata to saved wav metadata
   unprotected.setnchannels(nchannels)
   unprotected.setsampwidth(sampwidth)
   unprotected.setframerate(framerate)

   # write decrypted audio using writeframes
   unprotected.writeframes(audio)

   # close outfile
   unprotected.close()

def main():
   parser = ArgumentParser(description='main interface to unprotect songs')
   parser.add_argument('--outfile', help='path to save the unprotected song', required=True)
   parser.add_argument('--infile', help='path to protected song', required=True)
   parser.add_argument('--aes', help='path to AES key file', required=True)
   parser.add_argument('--rsa', help='path to RSA public key file', required=True)
   args = parser.parse_args()

   unprotect(args.infile, args.outfile, args.aes, args.rsa)

if __name__ == '__main__':
   main()
