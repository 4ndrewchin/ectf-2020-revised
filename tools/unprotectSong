#!/usr/bin/env python3
"""
Description: Unprotects song by removing signature, metadata, and decrypting audio
Use: Once per encrypted song
"""

import os
import wave
import math
import struct
import numpy as np
from argparse import ArgumentParser
from Cryptodome.Cipher import AES
from Cryptodome.Hash import SHA256, HMAC
from Cryptodome.PublicKey import RSA
from Cryptodome.Signature import pss
from Cryptodome.Util.Padding import unpad

CHUNK_SZ = 16000

'''
n - length of the last string hashed
s - ring buffer used for the internal state (32 words - 2048 bits)
      an element s[i] is a 64-bit word, which is the ith element of the buffer,
      wrapping around if necessary, when the index i becomes too large for the
      buffer
'''

def glowwormAddBit(b, s, n, t):
   if b == 1:
      t = s[n % 32] ^ 0xffffffff
   else:
      t = s[n % 32] ^ 0
   t = (t|(t>>1 & 0xffffffffffffffff)) ^ (t<<1 & 0xffffffffffffffff)
   t ^= (t>>4 & 0xffffffffffffffff) ^ (t>>8 & 0xffffffffffffffff) ^ (t>>16 & 0xffffffffffffffff) ^ (t>>32 & 0xffffffffffffffff)
   n = n + 1
   s[n % 32] = s[n % 32] ^ t
   h = s[n % 32] & 0xffffffffffffffff
   return h, s, n, t

def glowwormInit(s, n, t, h):
   for i in range(4096):
      h, s, n, t = glowwormAddBit((h & 1), s, n, t)
   return s, n, t, h

def glowwormHash(data, dataLen):
   CHECKVALUE = 0xCCA4220FC78D45E0
   s = [0] * 32
   h = 1
   n = 0
   t = 0

   s, n, t, h = glowwormInit(s, n, t, h)
   assert(h == CHECKVALUE)
   
   for idx in range(dataLen):
      currByte = data[idx]
      for bIdx in range(7, -1, -1):
         if ((currByte & (1<<bIdx))>>bIdx) == 0:
            bit = 0
         else:
            bit = 1
         h, s, n, t = glowwormAddBit(bit,s,n,t)

   return h

def unprotect(infile, outfile, aeskey_f, hmacMdKeyFile, hmacChunkKeyFile):
   # read aeskey_f into byte buffer
   try:
      aes = open(os.path.abspath(aeskey_f), 'rb')
   except Exception as e:
      print('Unable to open aes_key file: %s' % (e,))
      return 0
   aes_key = aes.read(32) #256/8
   aes.close()

   #read hmacKey's into buffer
   try:
      hmacMdKeyFd = open(os.path.abspath(hmacMdKeyFile), 'rb')
   except Exception as e:
      print('unable to open hmacMdKeyFile file: %s' % (e,))
      return 0
   hmacMdKey = hmacMdKeyFd.read()
   hmacMdKeyFd.close()

   try:
      hmacChunkKeyFd = open(os.path.abspath(hmacChunkKeyFile), 'rb')
   except Exception as e:
      print('unable to open hmacChunkKeyFile file: %s' % (e,))
      return 0
   hmacChunkKey = hmacChunkKeyFd.read()
   hmacChunkKeyFd.close()

   # wave.open infile
   try:
      protected = wave.open(os.path.abspath(infile), 'rb')
   except Exception as e:
      print('Unable to open infile: %s' % (e,))
      return 0

   # save wav metadata using getnchannels, getsampwidth, getframerate
   nchannels = protected.getnchannels()
   sampwidth = protected.getsampwidth()
   framerate = protected.getframerate()

   # read data and close infile
   nframes = protected.getnframes()
   data = np.frombuffer(protected.readframes(nframes), dtype=np.int16)
   data = data.tobytes()
   protected.close()

   # get segments of encrypted file
   gwMdHash_len = 8

   # get signature with first 256
   gwMdHash = data[:gwMdHash_len]

   # get iv
   end_iv = gwMdHash_len + 16
   iv = data[gwMdHash_len:end_iv]
   
   # get the number of 16000 chunks and audio length in bytes
   numChunks = data[end_iv:end_iv+4]
   intNumChunks = int.from_bytes(numChunks, byteorder='little', signed=False)
   audio_length = data[end_iv+4:end_iv+8]
   intAudioLength = int.from_bytes(audio_length, byteorder='little', signed=False)

   # get length of meta data
   # metadata is now ALWAYS 100 bytes
   meta_data_len = 100#data[end_iv+8] # first byte of md is len

   # get meta data
   end_meta_data = end_iv+8+meta_data_len
   meta_data = data[end_iv+8:end_meta_data]

   # get the encrypted AES audio
   enc_audio = data[end_meta_data:end_meta_data+intAudioLength]

   # get all hashes of each block
   block_hashes = data[end_meta_data+intAudioLength:]

   # recompute glowworm hash of [iv + nchunks + e_audio_len + MD + metadata key]
   toHash = iv + numChunks + audio_length + meta_data + hmacMdKey
   toHashLen = len(iv) + len(numChunks) + len(audio_length) + len(meta_data) + len(hmacMdKey)
   glowworm_md_hash = glowwormHash(toHash, toHashLen).to_bytes(8, byteorder='little', signed=False)
   
   print('Verifying metadata hash...', end='')
   if glowworm_md_hash != gwMdHash:
      print('metadata hash does not match')
      return 0
   print('success')

   # decrypt audio using AES key
   md_size = meta_data[0] #first byte of song metadata is length
   if md_size > 100:
      print('Something is wrong. Metadata max size is 100, got %s' % md_size)
      return 0
   cipher = AES.new(aes_key, AES.MODE_CBC, iv)

   #decrypting in chunks
   rem = len(enc_audio)
   print('Total encrypted length: '+str(rem))
   audio = bytes()
   print('Number of 16KB chunks: '+str(intNumChunks))
   counter = 0
   start = 0
   print('Verifying chunks and decrypting (this will take awhile)...', end='')
   for i in range(0, intNumChunks):

      counter = counter + 1
      if rem < CHUNK_SZ:
         increment = rem
      else:
         increment = CHUNK_SZ
      rem = rem - increment

      e_chunk = enc_audio[start:start+increment]
      start = start + increment

      # recompute the glowworm chunk hash of [enc audio chunk + iv bytes + chunk key]
      toHash = e_chunk + iv + hmacChunkKey
      toHashLen = len(e_chunk) + len(iv) + len(hmacChunkKey)
      glowworm_chunk_hash = glowwormHash(toHash, toHashLen).to_bytes(8, byteorder='little', signed=False)

      if glowworm_chunk_hash != block_hashes[i*8:8+i*8]:
         print('chunk hash #'+str(i)+' does not match')
         return 0

      # decrypt block
      p_chunk = cipher.decrypt(e_chunk)

      if i == intNumChunks-1:
         p_chunk = unpad(p_chunk, AES.block_size)
      audio += p_chunk

   print('success')

   # wave.open outfile
   try:
      unprotected = wave.open(os.path.abspath(outfile), 'wb')
   except Exception as e:
      print('Unable to open outfile: %s' % (e,))
      return 0

   print("Writing everything to .wav file...")

   # set outfile metadata to saved wav metadata
   unprotected.setnchannels(nchannels)
   unprotected.setsampwidth(sampwidth)
   unprotected.setframerate(framerate)

   # write decrypted audio using writeframes
   unprotected.writeframes(audio)

   # close outfile
   unprotected.close()

def main():
   parser = ArgumentParser(description='main interface to unprotect songs')
   parser.add_argument('--outfile', help='path to save the unprotected song', required=True)
   parser.add_argument('--infile', help='path to protected song', required=True)
   parser.add_argument('--aes', help='path to AES key file', required=True)
   parser.add_argument('--mdKey', help='path to hmac metadata key file', required=True)
   parser.add_argument('--chunkKey', help='path to hmac chunk key file', required=True)
   args = parser.parse_args()

   unprotect(args.infile, args.outfile, args.aes, args.mdKey, args.chunkKey)

if __name__ == '__main__':
   main()
