#!/usr/bin/env python3
"""
Description: Unprotects song by removing signature, metadata, and decrypting audio
Use: Once per encrypted song
"""

import os
import wave
import math
import struct
import numpy as np
from argparse import ArgumentParser
from Cryptodome.Cipher import AES
from Cryptodome.Util.Padding import unpad
from simon import SimonCipher

CHUNK_SZ = 16000

'''
n - length of the last string hashed
s - ring buffer used for the internal state (32 words - 2048 bits)
      an element s[i] is a 64-bit word, which is the ith element of the buffer,
      wrapping around if necessary, when the index i becomes too large for the
      buffer
'''

def glowwormAddBit(b, s, n, t):
   if b == 1:
      t = s[n % 32] ^ 0xffffffff
   else:
      t = s[n % 32] ^ 0
   t = (t|(t>>1 & 0xffffffffffffffff)) ^ (t<<1 & 0xffffffffffffffff)
   t ^= (t>>4 & 0xffffffffffffffff) ^ (t>>8 & 0xffffffffffffffff) ^ (t>>16 & 0xffffffffffffffff) ^ (t>>32 & 0xffffffffffffffff)
   n = n + 1
   s[n % 32] = s[n % 32] ^ t
   h = s[n % 32] & 0xffffffffffffffff
   return h, s, n, t

def glowwormInit(s, n, t, h):
   for i in range(4096):
      h, s, n, t = glowwormAddBit((h & 1), s, n, t)
   return s, n, t, h

def glowwormHash(data, dataLen):
   CHECKVALUE = 0xCCA4220FC78D45E0
   s = [0] * 32
   h = 1
   n = 0
   t = 0

   s, n, t, h = glowwormInit(s, n, t, h)
   assert(h == CHECKVALUE)
   
   for idx in range(dataLen):
      currByte = data[idx]
      for bIdx in range(7, -1, -1):
         if ((currByte & (1<<bIdx))>>bIdx) == 0:
            bit = 0
         else:
            bit = 1
         h, s, n, t = glowwormAddBit(bit,s,n,t)

   return h

def simon_decrypt_chunk(cipher, chunk, len):
   p_chunk = bytes()
   for i in range(0,len,AES.block_size):
      dec_simon_chunk = cipher.decrypt(int.from_bytes(chunk[i:i+AES.block_size], byteorder='little', signed='False'))
      dec_simon_chunk = dec_simon_chunk.to_bytes(AES.block_size, byteorder='little')
      p_chunk += dec_simon_chunk
   return p_chunk

def unprotect(infile, outfile, simonkey_f, mdKeyFile, chunkKeyFile):
   # read simonkey_f into byte buffer
   try:
      simon = open(os.path.abspath(simonkey_f), 'rb')
   except Exception as e:
      print('Unable to open simon_key file: %s' % (e,))
      return 0
   simon_key = simon.read(32) #256/8
   simon.close()

   #read glowworm hash keys into buffer
   try:
      mdKeyFd = open(os.path.abspath(mdKeyFile), 'rb')
   except Exception as e:
      print('unable to open mdKeyFile file: %s' % (e,))
      return 0
   mdKey = mdKeyFd.read()
   mdKeyFd.close()

   try:
      chunkKeyFd = open(os.path.abspath(chunkKeyFile), 'rb')
   except Exception as e:
      print('unable to open chunkKeyFile file: %s' % (e,))
      return 0
   chunkKey = chunkKeyFd.read()
   chunkKeyFd.close()

   # wave.open infile
   try:
      protected = wave.open(os.path.abspath(infile), 'rb')
   except Exception as e:
      print('Unable to open infile: %s' % (e,))
      return 0

   # save wav metadata using getnchannels, getsampwidth, getframerate
   nchannels = protected.getnchannels()
   sampwidth = protected.getsampwidth()
   framerate = protected.getframerate()

   # read data and close infile
   nframes = protected.getnframes()
   data = np.frombuffer(protected.readframes(nframes), dtype=np.int16)
   data = data.tobytes()
   protected.close()

   # get segments of encrypted file
   gwMdHash_len = 8

   # get signature with first 256
   gwMdHash = data[:gwMdHash_len]

   # get iv
   end_iv = gwMdHash_len + 16
   iv = data[gwMdHash_len:end_iv]
   
   # get the number of 16000 chunks and audio length in bytes
   numChunks = data[end_iv:end_iv+4]
   intNumChunks = int.from_bytes(numChunks, byteorder='little', signed=False)
   audio_length = data[end_iv+4:end_iv+8]
   intAudioLength = int.from_bytes(audio_length, byteorder='little', signed=False)

   # get length of meta data
   # metadata is now ALWAYS 100 bytes
   meta_data_len = 100#data[end_iv+8] # first byte of md is len

   # get meta data
   end_meta_data = end_iv+8+meta_data_len
   meta_data = data[end_iv+8:end_meta_data]

   # get the encrypted simon audio
   enc_audio = data[end_meta_data:end_meta_data+intAudioLength]

   # get all hashes of each block
   block_hashes = data[end_meta_data+intAudioLength:]

   # recompute glowworm hash of [iv + nchunks + e_audio_len + MD + metadata key]
   toHash = iv + numChunks + audio_length + meta_data + mdKey
   toHashLen = len(iv) + len(numChunks) + len(audio_length) + len(meta_data) + len(mdKey)
   glowworm_md_hash = glowwormHash(toHash, toHashLen).to_bytes(8, byteorder='little', signed=False)
   
   print('Verifying metadata hash...', end='')
   if glowworm_md_hash != gwMdHash:
      print('metadata hash does not match')
      return 0
   print('success')

   # decrypt audio using simon key
   md_size = meta_data[0] #first byte of song metadata is length
   if md_size > 100:
      print('Something is wrong. Metadata max size is 100, got %s' % md_size)
      return 0
   simonkey_int = int.from_bytes(simon_key, byteorder='little', signed='False')
   iv_int = int.from_bytes(iv, byteorder='little', signed='False')
   cipher = SimonCipher(simonkey_int, 256, 128, 'CBC', iv_int)

   #decrypting in chunks
   rem = len(enc_audio)
   print('Total encrypted length: '+str(rem))
   audio = bytes()
   print('Number of 16KB chunks: '+str(intNumChunks))
   counter = 0
   start = 0
   print('Verifying chunks and decrypting (this will take awhile)...', end='')
   for i in range(0, intNumChunks):

      counter = counter + 1
      if rem < CHUNK_SZ:
         increment = rem
      else:
         increment = CHUNK_SZ
      rem = rem - increment

      e_chunk = enc_audio[start:start+increment]
      start = start + increment

      # recompute the glowworm chunk hash of [enc audio chunk + iv bytes + chunk key]
      toHash = e_chunk + iv + chunkKey
      toHashLen = len(e_chunk) + len(iv) + len(chunkKey)
      glowworm_chunk_hash = glowwormHash(toHash, toHashLen).to_bytes(8, byteorder='little', signed=False)

      if glowworm_chunk_hash != block_hashes[i*8:8+i*8]:
         print('chunk hash #'+str(i)+' does not match')
         return 0

      # decrypt block
      p_chunk = simon_decrypt_chunk(cipher, e_chunk, increment)

      if i == intNumChunks-1:
         p_chunk = unpad(p_chunk, AES.block_size)
      audio += p_chunk

   print('success')

   # wave.open outfile
   try:
      unprotected = wave.open(os.path.abspath(outfile), 'wb')
   except Exception as e:
      print('Unable to open outfile: %s' % (e,))
      return 0

   print("Writing everything to .wav file...")

   # set outfile metadata to saved wav metadata
   unprotected.setnchannels(nchannels)
   unprotected.setsampwidth(sampwidth)
   unprotected.setframerate(framerate)

   # write decrypted audio using writeframes
   unprotected.writeframes(audio)

   # close outfile
   unprotected.close()
   
   print('success')

def main():
   parser = ArgumentParser(description='main interface to unprotect songs')
   parser.add_argument('--outfile', help='path to save the unprotected song', required=True)
   parser.add_argument('--infile', help='path to protected song', required=True)
   parser.add_argument('--simon', help='path to simon key file', required=True)
   parser.add_argument('--mdKey', help='path to metadata key file', required=True)
   parser.add_argument('--chunkKey', help='path to chunk key file', required=True)
   args = parser.parse_args()

   unprotect(args.infile, args.outfile, args.simon, args.mdKey, args.chunkKey)

if __name__ == '__main__':
   main()
