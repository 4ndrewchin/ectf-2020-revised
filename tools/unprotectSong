#!/usr/bin/env python3
"""
Description: Unprotects song by removing signature, metadata, and decrypting audio
Use: Once per encrypted song
"""

import os
import wave
import math
import struct
import numpy as np
from argparse import ArgumentParser
from Cryptodome.Cipher import AES
from Cryptodome.Hash import SHA256, HMAC
from Cryptodome.PublicKey import RSA
from Cryptodome.Signature import pss
from Cryptodome.Util.Padding import unpad
from speck import SpeckCipher

CHUNK_SZ = 16000

def speck_decrypt_chunk(cipher, chunk, len):
   p_chunk = bytes()
   for i in range(0,len,AES.block_size):
      dec_speck_chunk = cipher.decrypt(int.from_bytes(chunk[i:i+AES.block_size], byteorder='little', signed='False'))
      dec_speck_chunk = dec_speck_chunk.to_bytes(AES.block_size, byteorder='little')
      p_chunk += dec_speck_chunk
   return p_chunk

def unprotect(infile, outfile, aeskey_f, hmacMdKeyFile, hmacChunkKeyFile):
   # read aeskey_f into byte buffer
   try:
      aes = open(os.path.abspath(aeskey_f), 'rb')
   except Exception as e:
      print('Unable to open aes_key file: %s' % (e,))
      return 0
   aes_key = aes.read(32) #256/8
   aes.close()

   #read hmacKey's into buffer
   try:
      hmacMdKeyFd = open(os.path.abspath(hmacMdKeyFile), 'rb')
   except Exception as e:
      print('unable to open hmacMdKeyFile file: %s' % (e,))
      return 0
   hmacMdKey = hmacMdKeyFd.read()
   hmacMdKeyFd.close()

   try:
      hmacChunkKeyFd = open(os.path.abspath(hmacChunkKeyFile), 'rb')
   except Exception as e:
      print('unable to open hmacChunkKeyFile file: %s' % (e,))
      return 0
   hmacChunkKey = hmacChunkKeyFd.read()
   hmacChunkKeyFd.close()

   # wave.open infile
   try:
      protected = wave.open(os.path.abspath(infile), 'rb')
   except Exception as e:
      print('Unable to open infile: %s' % (e,))
      return 0

   # save wav metadata using getnchannels, getsampwidth, getframerate
   nchannels = protected.getnchannels()
   sampwidth = protected.getsampwidth()
   framerate = protected.getframerate()

   # read data and close infile
   nframes = protected.getnframes()
   data = np.frombuffer(protected.readframes(nframes), dtype=np.int16)
   data = data.tobytes()
   protected.close()

   # get segments of encrypted file
   signature_len = 32

   # get signature with first 256
   signature = data[:signature_len]

   # get iv
   end_iv = signature_len + 16
   iv = data[signature_len:end_iv]
   
   # get the number of 16000 chunks and audio length in bytes
   numChunks = data[end_iv:end_iv+4]
   intNumChunks = int.from_bytes(numChunks, byteorder='little', signed=False)
   audio_length = data[end_iv+4:end_iv+8]
   intAudioLength = int.from_bytes(audio_length, byteorder='little', signed=False)

   # get length of meta data
   # metadata is now ALWAYS 100 bytes
   meta_data_len = 100#data[end_iv+8] # first byte of md is len

   # get meta data
   end_meta_data = end_iv+8+meta_data_len
   meta_data = data[end_iv+8:end_meta_data]

   # get the encrypted AES audio
   enc_audio = data[end_meta_data:end_meta_data+intAudioLength]

   # get all hashes of each block
   block_hashes = data[end_meta_data+intAudioLength:]

   # recompute the hash of all metadata
   verifier = HMAC.new(hmacMdKey, iv, digestmod=SHA256) 
   verifier = verifier.update(numChunks)
   verifier = verifier.update(audio_length)
   verifier = verifier.update(meta_data)
   #verifier = verifier.update(enc_audio)
   #verifier = verifier.update(block_hashes)

   print('Verifying metadata signature...', end='')
   try:
      verifier.verify(signature)
   except Exception as e:
      print('error: %s' % (e,))
      return 0
   print('success')

   # decrypt audio using AES key
   md_size = meta_data[0] #first byte of song metadata is length
   if md_size > 100:
      print('Something is wrong. Metadata max size is 100, got %s' % md_size)
      return 0
   #cipher = AES.new(aes_key, AES.MODE_CBC, iv)
   aeskey_int = int.from_bytes(aes_key, byteorder='little', signed='False')
   iv_int = int.from_bytes(iv, byteorder='little', signed='False')
   cipher = SpeckCipher(aeskey_int, 256, 128, 'CBC', iv_int)

   #decrypting in chunks
   rem = len(enc_audio)
   print('TOTAL ENCRYPTED LEN: '+str(rem))
   audio = bytes()
   print('num 16KB chunks: '+str(intNumChunks))
   counter = 0
   start = 0
   for i in range(0, intNumChunks):

      counter = counter + 1
      if rem < CHUNK_SZ:
         increment = rem
      else:
         increment = CHUNK_SZ
      rem = rem - increment

      e_chunk = enc_audio[start:start+increment]
      start = start + increment

      # recompute the hash
      try:
         h = HMAC.new(hmacChunkKey, e_chunk+iv, digestmod=SHA256)
         h.verify(block_hashes[i*32:32+i*32])
      except Exception as e:
         print('Failed to verify chunk #' + str(i))
         return 0

      # decrypt block
      #p_chunk = cipher.decrypt(e_chunk)
      p_chunk = speck_decrypt_chunk(cipher, e_chunk, increment)

      if i == intNumChunks-1:
         p_chunk = unpad(p_chunk, AES.block_size)
      audio += p_chunk

   print('Song successfully decrypted')

   # wave.open outfile
   try:
      unprotected = wave.open(os.path.abspath(outfile), 'wb')
   except Exception as e:
      print('Unable to open outfile: %s' % (e,))
      return 0

   # set outfile metadata to saved wav metadata
   unprotected.setnchannels(nchannels)
   unprotected.setsampwidth(sampwidth)
   unprotected.setframerate(framerate)

   # write decrypted audio using writeframes
   unprotected.writeframes(audio)

   # close outfile
   unprotected.close()

def main():
   parser = ArgumentParser(description='main interface to unprotect songs')
   parser.add_argument('--outfile', help='path to save the unprotected song', required=True)
   parser.add_argument('--infile', help='path to protected song', required=True)
   parser.add_argument('--aes', help='path to AES key file', required=True)
   parser.add_argument('--mdKey', help='path to hmac metadata key file', required=True)
   parser.add_argument('--chunkKey', help='path to hmac chunk key file', required=True)
   args = parser.parse_args()

   unprotect(args.infile, args.outfile, args.aes, args.mdKey, args.chunkKey)

if __name__ == '__main__':
   main()
