#!/usr/bin/env python3
"""
Description: Creates device specific secrets
Use: Once per device
"""
import os
import json
from argparse import ArgumentParser
from base64 import b64decode, b64encode


def main(region_names, user_names, user_secrets, region_secrets, device_dir, region_secrets_path):
    file_name = "device_secrets"

    # create device directory
    try:
        os.mkdir(device_dir)
    except Exception as e:
        print("Could not create directory {device_dir}: {e}".format(device_dir=device_dir, e=e))
        return

    # create device secrets file
    try:
        device_secrets = open(os.path.join(device_dir, file_name), "w")
    except Exception as e:
        print("Unable to open secrets file: {e}".format(e=e))
        return

    # check for valid region names
    try:
        rids = [str(region_secrets[r]) for r in region_names]
    except Exception as e:
        print("Unable to create secrets file: {e} "
              "Please ensure all regions entered are in the list: {user_secrets}".format(e=e, user_secrets=user_secrets.keys()))
        return

    # check for valid user names
    try:
        uids = [str(user_secrets[u]['id']) for u in usernames]
    except Exception as e:
        print("Unable to create secrets file: {e} "
              "Please ensure all regions entered are in the list: {user_secrets}".format(e=e, user_secrets=user_secrets.keys()))
        return

    # get simon key
    try:
        simon_path = os.path.abspath(get_path(region_secrets_path)+'simon_key')
        simon = open(simon_path, 'rb')
    except Exception as e:
        print('Unable to open simon_key file: {e}'.format(e=e))
        return
    simon_key = simon.read(32)
    simon.close()

    # get glowworm metadata key
    try:
        mdPath = os.path.abspath(get_path(region_secrets_path)+'md_key')
        mdKeyFd = open(mdPath, 'rb')
    except Exception as e:
        print('Unable to open md_key file: {e}'.format(e=e))
        return
    mdKey = mdKeyFd.read(32)
    mdKeyFd.close()

    # get glowworm chunk key
    try:
        chunkPath = os.path.abspath(get_path(region_secrets_path)+'chunk_key')
        chunkKeyFd = open(chunkPath, 'rb')
    except Exception as e:
        print('Unable to open chunk_key file: {e}'.format(e=e))
        return
    chunkKey = chunkKeyFd.read(32)
    chunkKeyFd.close()

    # write secrets
    device_secrets.write(f'''

/* autogenerated by tools/createDevice */

#ifndef SECRETS_H
#define SECRETS_H

#define NUM_REGIONS {len(region_secrets)}
const char *REGION_NAMES[] = {{ {", ".join(['"' + r + '"' for r in region_secrets])} }};
const u8 REGION_IDS[] = {{ {", ".join([str(r) for r in region_secrets.values()])} }};

#define NUM_PROVISIONED_REGIONS {len(region_names)}
const u8 PROVISIONED_RIDS[] = {{ {", ".join(rids)} }};

#define NUM_USERS {len(user_secrets)}
const char *USERNAMES[] = {{ {", ".join(['"' + u + '"' for u in user_secrets])} }};
const u8 USER_IDS[] = {{ {", ".join([str(user_secrets[u]['id']) for u in user_names])} }};

#define NUM_PROVISIONED_USERS {len(user_names)}
const u8 PROVISIONED_UIDS[] = {{ {", ".join(uids)} }};
const char *PROVISIONED_PINS[] = {{ {", ".join(['"' + user_secrets[u]['pin'] + '"' for u in user_names])} }};

/* BASE64 DECODE KEYS BEFORE USING */

#define SIMON_BLK_SZ 16
#define SIMON_KEY_SZ {len(simon_key)}
#define b64SIMON_KEY_SZ {len(b64encode(simon_key))}
const char *SIMON_KEY = {'"'+str(b64encode(simon_key)).strip("b'")+'"'};

#define MD_KEY_SZ {len(mdKey)}
#define b64MD_KEY_SZ {len(b64encode(mdKey))}
const char *MD_KEY = {'"'+str(b64encode(mdKey)).strip("b'")+'"'};

#define CHUNK_KEY_SZ {len(chunkKey)}
#define b64CHUNK_KEY_SZ {len(b64encode(chunkKey))}
const char *CHUNK_KEY = {'"'+str(b64encode(chunkKey)).strip("b'")+'"'};

#endif // SECRETS_H
''')

# removes filename from path
# Ex. './a/b/file.txt' --> './a/b/'
#     'file.txt'       --> ''
def get_path(full_path):
    found = False
    for i in range(len(full_path)-1, 0, -1):
        if full_path[i] == '/':
            found = True
            break
    dir = ''
    if found:
        dir = full_path[:i] + '/'
    return dir

def get_args():
    """gets arguments from command line"""
    parser = ArgumentParser(description='main interface to provision system')
    parser.add_argument('--region-list', nargs='+', help='Regions the player is provisioned for.', required=True)
    parser.add_argument('--region-secrets-path', help='Path to region secrets file.', required=True)
    parser.add_argument('--user-list', help='List of users seperated by a space to provision the device for.',
                        nargs='+', required=True)
    parser.add_argument('--user-secrets-path', help='Path to user secrets file generated in createUsers.py',
                        required=True)
    parser.add_argument('--device-dir', help='Path to output any required information for the device.',
                        required=True)
    args = parser.parse_args()
    return args.region_list, args.region_secrets_path, args.user_list, args.user_secrets_path, args.device_dir


if __name__ == '__main__':
    region_names, region_secrets, usernames, user_secrets, device_dir = get_args()
    print("generating device specific secrets")
    region_secrets_path = region_secrets
    user_secrets = json.load(open(os.path.abspath(user_secrets)))
    region_secrets = json.load(open(os.path.abspath(region_secrets)))
    main(region_names, usernames, user_secrets, region_secrets, device_dir, region_secrets_path)
