#!/usr/bin/env python3
"""
Description: Generates system wide secrets containing all potential regions and cryptographic keys
Use: Once per ecosystem of devices
"""
import json
import os
import sys
import string
import re
from argparse import ArgumentParser
from Cryptodome.PublicKey import RSA
from Cryptodome.Cipher import AES
from Cryptodome.Random import get_random_bytes

def main(region_dict, file_name):
    try:
        secrets = open(os.path.abspath(file_name), "w")
    except Exception as e:
        print("Unable to open secrets file: %s" % (e,))
        return 0

    json.dump(region_dict, secrets)
    secrets.close()

    dir = get_path(file_name)

    print("generating cryptographic keys")

    # Key for metadata and song
    key1 = get_random_bytes(32)
    try:
        hmacKey1 = open(os.path.abspath(dir+'hmac_md_key'), 'wb')
        try:
            hmacKey1.write(key1)
        except Exception as e:
            print("Failed to write to hmac_md_key file: %s" % (e,))
            sys.exit(e)
    except Exception as e:
        print("Unable to open hmac_md_key file: %s" % (e,))
        sys.exit(e)

    hmacKey1.close()

    # Key for hashes
    key2 = get_random_bytes(32)
    try:
        hmacKey2 = open(os.path.abspath(dir+'hmac_chunk_key'), 'wb')
        try:
            hmacKey2.write(key2)
        except Exception as e:
            print("Failed to write to hmac_chunk_key file: %s" % (e,))
            sys.exit(e)
    except Exception as e:
        print("Unable to open hmac_chunk_key file: %s" % (e,))
        sys.exit(e)
    hmacKey2.close()

    #AES
    try:
        aes = open(os.path.abspath(dir+"aes_key"), "wb")
    except Exception as e:
        print("Unable to open aes_key file: %s" % (e,))
        sys.exit(e)
    try:
        aes.write(get_random_bytes(32)) # 256-bit key
    except Exception as e:
        print("Unable to write to aes_key file: %s" % (e,))
        sys.exit(e)
    aes.close()

# removes filename from path
# Ex. './a/b/file.txt' --> './a/b/'
#     'file.txt'       --> ''
def get_path(full_path):
    found = False
    for i in range(len(full_path)-1, 0, -1):
        if full_path[i] == '/':
            found = True
            break
    dir = ''
    if found:
        dir = full_path[:i] + '/'
    return dir

def get_args():
    """gets arguments from command line"""
    parser = ArgumentParser(description='main interface to provision system')
    parser.add_argument('--region-list', help='list of regions for provisioning purposes',
                        required=True, nargs='+')
    parser.add_argument('--outfile', help='file to save region secrets to', required=True)
    args = parser.parse_args()
    return args.region_list, args.outfile

# check for duplicate entries and invalid characters
# return error string if invalid
def validate_list(list):
    # look for invalid characters
    for i in range(len(list)):
        s = list[i]
        match = re.search(r'[^A-Za-z\s]', s)
        if match:
            return "list contains invalid characters [^A-Za-z\s]"
    # trim leading/trailing whitespace
    # also reduce all whitespace within str into single space
    for i in range(len(list)):
        s = list[i]
        list[i] = " ".join(s.split())
    # look for dupes
    if len(list) != len(set(list)):
        return "list contains duplicates"
    return ''

if __name__ == '__main__':
    region_list, outfile = get_args()
    print("generating system specific secrets")
    error_str = validate_list(region_list)
    if error_str:
        print("Error: ", error_str)
    else:
        regions = {region: num for num, region in enumerate(region_list)}  # Create region IDs based on increasing integers
        main(regions, outfile)
